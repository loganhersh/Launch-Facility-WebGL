<!DOCTYPE html>
<meta charset="UTF-8">
<html lang="en">
<!--
    File: p4.html
    Date: 13 October 2019
    Author: Logan Hershberger
    Purpose: 3D WebGL scene depicting a MinutemanIII launch facility.
             There are a few light sources that can be toggled on and off.
             Two range sliders control moving doors, one of which (the launcher closure) can
             be opened fully to allow the missile to launch.

             The scene can be maneuvered by clicking and dragging, arrow key presses, and scrolling.
             The home button resets the position of the scene.
             Arrow keys move the scene along the x, y, and z axes of the world coordinates.
             This can seem strange after the scene has been rotated.

    diskworld-2.html was used as a template for this program.
    ------------------------------------------------------------------------------------
    Title: diskworld-2.html
    Author: D. J. Eck
    Date: January 2018
    Availability: http://math.hws.edu/graphicsbook/source/webgl/diskworld-2.html
    ------------------------------------------------------------------------------------
-->
<head>
  <title>MMIII Launch Facility</title>
  <style>
    body {
      background-color: #EEEEEE;
    }
    label {
      white-space: pre;
      margin-left: 25px;
    }
  </style>

  <script type="x-shader/x-vertex" id="vshader-source">
    attribute vec3 a_coords;
    attribute vec3 a_normal;
    attribute vec2 a_texCoords;
    uniform mat4 modelview;
    uniform mat4 projection;
    uniform mat3 textureTransform;
    varying vec3 v_normal;
    varying vec3 v_eyeCoords;
    varying vec2 v_texCoords;
    void main() {
        vec4 coords = vec4(a_coords,1.0);
        vec4 eyeCoords = modelview * coords;
        gl_Position = projection * eyeCoords;
        v_normal = normalize(a_normal);
        v_eyeCoords = eyeCoords.xyz/eyeCoords.w;
        vec3 texcoords = textureTransform * vec3(a_texCoords,1.0);
        v_texCoords = texcoords.xy;
    }
  </script>

  <script type="x-shader/x-fragment" id="fshader-source">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
       precision highp float;
    #else
       precision mediump float;
    #endif
    struct MaterialProperties {
        vec4 diffuseColor;      // diffuseColor.a is alpha for the fragment
        vec3 specularColor;
        vec3 emissiveColor;
        float specularExponent;
    };
    struct LightProperties {
        bool enabled;
        vec4 position;
        vec3 color;
        float attenuation;   // Linear attenuation factor, >= 0. Only point lights attenuate.
        vec3 spotDirection;  // Note: only a point light can be a spotlight
        float spotCosineCutoff; // if <= 0, this is not a spotlight, if >= 1, the light cone shrinks to nothing
        float spotExponent;
    };
    uniform MaterialProperties material; // do two-sided lighting, but assume front and back materials are the same
    uniform LightProperties lights[8];
    uniform mat3 normalMatrix;
    uniform float useTexture;
    uniform sampler2D texture;
    varying vec3 v_normal;
    varying vec3 v_eyeCoords;
    varying vec2 v_texCoords;
    vec3 lightingEquation( LightProperties light, MaterialProperties material,
                                vec3 eyeCoords, vec3 N, vec3 V ) {
           // N is normal vector, V is direction to viewer.
        vec3 L, R; // Light direction and reflected light direction.
        float spotFactor = 1.0;  // multiplier to account for spotlight
        float attenuationFactor = 1.0; // multiplier to account for light attenuation with distance
        if ( light.position.w == 0.0 ) {
            L = normalize( light.position.xyz );
        }
        else {  // point light
            L = normalize( light.position.xyz/light.position.w - v_eyeCoords );
            if (light.spotCosineCutoff > 0.0) { // the light is a spotlight
                vec3 D = -normalize(light.spotDirection);
                float spotCosine = dot(D,L);
                if (spotCosine > light.spotCosineCutoff) {
                    spotFactor = pow(spotCosine,light.spotExponent);
                    if(useTexture > 0.5) {
                        spotFactor = spotFactor * 3.0;
                    }
                }
                else { // The point is outside the cone of light from the spotlight.
                    spotFactor = 0.0; // The light will add no color to the point.
                }
            }
            if (light.attenuation > 0.0) {
                float dist = distance(eyeCoords,light.position.xyz/light.position.w);
                attenuationFactor = 1.0 / (1.0 + dist*light.attenuation);
            }
        }
        if (dot(L,N) <= 0.0) {
            return vec3(0.0);
        }
        vec3 reflection = dot(L,N) * light.color * material.diffuseColor.rgb;
        R = -reflect(L,N);
        if (dot(R,V) > 0.0) {
            float factor = pow(dot(R,V),material.specularExponent);
            reflection += factor * material.specularColor * light.color;
        }
        return spotFactor*attenuationFactor*reflection;
    }
    void main() {
        vec3 normal = normalize( normalMatrix*v_normal );
        vec3 viewDirection = normalize( -v_eyeCoords);  // (Assumes a perspective projection.)
        float diffuseFactor = dot(normal,viewDirection) - 0.1;  // alters texture lighting
        vec3 color;
        if (useTexture > 0.5) {   // object uses texture and the texture was loaded
            color = vec3(texture2D(texture, v_texCoords))*material.diffuseColor.rgb;
            for (int i = 0; i < 8; i++) {
              if (lights[i].enabled) {
                if (gl_FrontFacing) {
                  color += lightingEquation( lights[i], material, v_eyeCoords,
                                  normal, viewDirection);
                 }
                else {
                  color += lightingEquation( lights[i], material, v_eyeCoords,
                                  -normal, viewDirection);
                }
              }
            }
            gl_FragColor = vec4(diffuseFactor*color,1);
        } else {    // object does not use texture
            color = material.emissiveColor;
            for (int i = 0; i < 8; i++) {
              if (lights[i].enabled) {
                if (gl_FrontFacing) {
                  color += lightingEquation( lights[i], material, v_eyeCoords,
                                  normal, viewDirection);
                 }
                else {
                  color += lightingEquation( lights[i], material, v_eyeCoords,
                                  -normal, viewDirection);
                }
              }
            }
            gl_FragColor = vec4(color,material.diffuseColor.a);
        }
    }
</script>

  <script src="gl-matrix.js"></script>
  <script src="trackball-rotator.js"></script>
  <script src="basic-object-models-IFS.js"></script>
  <script>

    "use strict";
    var gl;   // The webgl context.

    var a_coords_loc;         // Location of the a_coords attribute variable in the shader program.
    var a_normal_loc;         // Location of a_normal attribute
    var a_texCoords_loc;      // Location of a_texCoords attribute

    var u_texture;       // Location of texture uniform
    var u_useTexture;    // float used in the fragment shader to determine if object uses a texture
                         // 1.0 = texture; 0.0 = no texture
                         // Necessary because the same shaders are used for all objects

    var u_modelview;
    var u_projection;
    var u_normalMatrix;
    var u_textureTransform;


    var u_material;     // All objects use the same material
    var u_lights;       // An array of objects that holds uniform locations for light properties.

    var projection = mat4.create();    // projection matrix
    var modelview;                     // modelview matrix; value comes from rotator
    var normalMatrix = mat3.create();  // matrix, derived from modelview matrix, for transforming normal vectors
    var textureTransform = mat3.create();  // texture transformation matrix

    var rotator;  // A TrackballRotator to implement rotation by mouse.

    var frameNumber = 0;  // frame number during animation
    var stage = 1;        // used in the launch animation to determine length of thrust trail
    var launching = false;  // true when missile is launching
    var missileReady = true;
    var missileZ = 0;
    var lcOpen = false;   // true when launcher closure is fully open

    // basic objects used to build the scene
    var sphere, cone, cylinder, rack;
    var nozzle, stage1, stage2, interstage, launchTubeLamp, tube, lerFloor, pasTube;
    var gcube, gwedge, lcWheel, lcTrack, pasTubeRing, fenceRing, pahRing;
    var thrustCones, lampSlice, lampRingSlice;

    var texture;
    var textureURLs = [
      "images/usaf.png",
      "images/stage2texture.png",
      "images/white.png",
      "images/grass.jpg",
      "images/concrete.png",
      "images/lc.png",
      "images/flames.jpg"
    ];
    var textureObjects = [7];    // array of texture objects
    var textureEnums;            // array of texture enums starting at gl.TEXTURE0

    var matrixStack = [];           // A stack of matrices for implementing hierarchical graphics.
    var currentColor = [1,1,1,1];   // The current diffuseColor; render() functions in the basic objects set
                                    // the diffuse color to currentColor when it is called before drawing the object.
                                    // Other color properties, which don't change often are handled elsewhere.

    var lcOpenValue = 0;    // used to determine position of launcher closure
    var pahOpenValue = 0;    // used to determine position of PAH
    var lampNum = 0;
    var launchTubeLights = false;
    var pasLight = false;
    var testLight = false;
    var sunLight = false;
    var keyTranslation = [0,0,-5];   // translation from key presses
    var mouseX,mouseY;    // tracks mouse position to determine whether wheel event should zoom

    // Called every time the scene is rendered
    function draw() {
      gl.clearColor(0.53,0.81,0.98,1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      mat4.perspective(projection, Math.PI/4, 1, 1, 120);
      gl.uniformMatrix4fv(u_projection, false, projection );

      modelview = rotator.getViewMatrix();

      if(launching){
        var fade = 0.0001 * frameNumber * frameNumber + 1;
        var x = 0;

        // simulates vibration as the missile launches
        if(frameNumber%4 === 0){
          x -= 1 / fade;
        } else if(frameNumber%8 === 0) {
          x += 1 / fade;
        }
        mat4.translate(modelview,modelview,[x,0,-5]);
      } else {
        mat4.translate(modelview, modelview, keyTranslation);  // translate scene depending on the keypresses
      }
      lights();

      launchFacility();
    }

    /* Set the direction vector of a light, in eye coordinates.
     * (Note: This function sets the value of the global variable normalMatrix.)
     * @param modelview the matrix that does object-to-eye coordinate transforms
     * @param u_direction_loc the uniform variable location for the spotDirection property of the light
     * @param lightDirection a vector that points in the direction that the spotlight is pointing (a vec3)
     */
    function setSpotlightDirection( u_direction_loc, modelview, lightDirection ) {
      mat3.normalFromMat4(normalMatrix,modelview);
      var transformedDirection = new Float32Array(3);
      vec3.transformMat3(transformedDirection, lightDirection, normalMatrix);
      gl.uniform3fv(u_direction_loc, transformedDirection);
    }

    /* Set the position of a light, in eye coordinates.
     * @param u_position_loc the uniform variable location for the position property of the light
     * @param modelview the matrix that does object-to-eye coordinate transforms
     * @param lightPosition the location of the light, in object coordinates (a vec4)
     */
    function setLightPosition( u_position_loc, modelview, lightPosition ) {
      var transformedPosition = new Float32Array(4);
      vec4.transformMat4(transformedPosition, lightPosition, modelview);
      gl.uniform4fv(u_position_loc, transformedPosition);
    }

    /* Configures the lights in the scene based on the checkboxes.
     * Also creates the lamps that visually represent the light sources
     */
    function lights() {
      launchTubeLights = document.getElementById("ltlights").checked;
      sunLight = document.getElementById("sunlight").checked;
      pasLight = document.getElementById("paslight").checked;

      // configure sunlight
      gl.uniform3f( u_lights[1].color, 0.5, 0.5, 0.5 );
      gl.uniform1f( u_lights[1].attenuation, 0 );
      setLightPosition(u_lights[1].position, modelview, [0,0,1,0]);
      if(sunLight){
        gl.uniform1f(u_lights[1].enabled, 1);
      } else {
        gl.uniform1f(u_lights[1].enabled, 0);
      }

      // configure light used in testing
      if(testLight) {
        gl.uniform1f(u_lights[0].enabled, 1);
      } else {
        gl.uniform1f(u_lights[0].enabled, 0);
      }

      // configure launch tube lights
      currentColor = [ 0.3, 0.3, 0.3, 1 ];
      if (launchTubeLights) {  // if launch tube lights are on
        gl.uniform3f( u_material.emissiveColor, 0.6, 0.6, 0.5 );
        gl.uniform1f( u_lights[2].enabled, 1 );
        gl.uniform1f( u_lights[3].enabled, 1 );
        gl.uniform1f( u_lights[4].enabled, 1 );
      } else {
        gl.uniform3f(u_material.emissiveColor, 0.1, 0.1, 0.1 );
        gl.uniform1f( u_lights[2].enabled, 0 );
        gl.uniform1f( u_lights[3].enabled, 0 );
        gl.uniform1f( u_lights[4].enabled, 0 );
      }

      // create lamps
      pushMatrix();
      mat4.translate(modelview,modelview,[3.45,0,11]);
      mat4.rotateZ(modelview,modelview,Math.PI/2);
      launchTubeLamp.render();
      popMatrix();
      pushMatrix();
      mat4.rotateZ(modelview,modelview,Math.PI);
      mat4.translate(modelview,modelview,[3.45,0,11]);
      mat4.rotateZ(modelview,modelview,Math.PI/2);
      launchTubeLamp.render();
      popMatrix();
      pushMatrix();
      mat4.rotateZ(modelview,modelview,-Math.PI/2);
      mat4.translate(modelview,modelview,[3.45,0,11]);
      mat4.rotateZ(modelview,modelview,Math.PI/2);
      launchTubeLamp.render();
      popMatrix();

      setLightPosition(u_lights[2].position, modelview, [3.5,0,11,1]);
      setSpotlightDirection(u_lights[2].spotDirection, modelview, [-1,0,-2]);

      setLightPosition(u_lights[3].position, modelview, [-3.5,0,11,1]);
      setSpotlightDirection(u_lights[3].spotDirection, modelview, [1,0,-2]);

      setLightPosition(u_lights[4].position, modelview, [0,-3.5,11,1]);
      setSpotlightDirection(u_lights[4].spotDirection, modelview, [0,1,-2]);

      // configure PAS light
      if (pasLight) {
        gl.uniform3f( u_material.emissiveColor, 0.6, 0.6, 0.5 );
        gl.uniform1f( u_lights[5].enabled, 1 );
      } else {
        gl.uniform3f(u_material.emissiveColor, 0.1, 0.1, 0.1 );
        gl.uniform1f( u_lights[5].enabled, 0 );
      }

      // create PAS lamp
      pushMatrix();
      mat4.translate(modelview,modelview,[7.5,3.8,12]);
      mat4.scale(modelview,modelview,[0.7,0.7,0.7]);
      launchTubeLamp.render();
      popMatrix();

      setLightPosition(u_lights[5].position, modelview, [7.5,3.8,12,1]);
      setSpotlightDirection(u_lights[5].spotDirection, modelview, [0,1,0]);

      // configure alarm lights
      if(lcOpen) {
        gl.uniform1f( u_lights[6].enabled, 1 );
        gl.uniform1f( u_lights[7].enabled, 1 );
      } else {
        gl.uniform1f( u_lights[6].enabled, 0 );
        gl.uniform1f( u_lights[7].enabled, 0 );
      }

      pushMatrix();
      setLightPosition(u_lights[6].position,modelview,[-10,10,21.5,1]);
      setLightPosition(u_lights[7].position,modelview,[-10,10,21.5,1]);
      mat4.rotateZ(modelview,modelview,lampNum*Math.PI/10);
      setSpotlightDirection(u_lights[6].spotDirection, modelview, [-1,0,-1]);
      setSpotlightDirection(u_lights[7].spotDirection, modelview, [1,0,-1]);
      popMatrix();

      gl.uniform3f( u_material.emissiveColor, 0, 0, 0 );
    }

    function launchFacility() {
      launchTube();
      // upper ground
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,14.2]);
      upperGround();
      popMatrix();

      // launcher closure and tracks
      pushMatrix();
      mat4.translate(modelview,modelview,[0,-lcOpenValue,14.425]);
      launcherClosure();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[0,-8.5,12.6]);
      launcherClosureTracks();
      popMatrix();

      // missile
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,-7]);
      mat4.rotateZ(modelview,modelview,Math.PI/2);
      mat4.scale(modelview,modelview,[2,2,2]);
      missile();
      popMatrix();

      // LER
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,4]);
      mat4.rotateZ(modelview,modelview,-Math.PI/4);
      lowerEquipRoom();
      popMatrix();

      // PAS
      pushMatrix();
      mat4.translate(modelview,modelview,[7.5,5,8.55]);
      pas();
      popMatrix();

      // PAS Ladder
      currentColor = [0.1,0.1,0.1,1];
      pushMatrix();
      mat4.translate(modelview,modelview,[7.5,5.9,8.55]);
      mat4.scale(modelview,modelview,[0.5,0.5,0.45]);
      ladder();
      popMatrix();

      // PAH Assy
      pushMatrix();
      mat4.translate(modelview,modelview,[7.5,2.6,16.25]);
      mat4.rotateZ(modelview,modelview,Math.PI);
      pahAssembly();
      popMatrix();

      // fence
      pushMatrix();
      mat4.translate(modelview,modelview,[0,17,0]);
      fence();
      popMatrix();

      // alarm light
      pushMatrix();
      mat4.translate(modelview,modelview,[-10,10,14.5]);
      alarmLight();
      popMatrix();
    }

    function alarmLight() {
      pushMatrix();
      mat4.scale(modelview,modelview,[0.5,0.5,6]);
      cylinder.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,6]);
      mat4.scale(modelview,modelview,[0.6,0.6,0.5]);
      cylinder.render();
      popMatrix();

      var alarm = function() {
        if(lcOpen){
          if(frameNumber%5 === 0) lampNum++;
          if(lampNum > 9) lampNum = 0;
        }
        var lampHalf = function() {
          for(var i=0; i<10; i++) {
            if(lcOpen){
              if(lampNum === i) gl.uniform3f(u_material.emissiveColor, 1, 0, 0 );
              else if(Math.abs(lampNum-i) === 1) gl.uniform3f(u_material.emissiveColor, 0.8,0,0);
              else if(Math.abs(lampNum-i) === 2) gl.uniform3f(u_material.emissiveColor, 0.55,0,0);
              else if(Math.abs(lampNum-i) === 3) gl.uniform3f(u_material.emissiveColor, 0.3,0,0);
              else gl.uniform3f(u_material.emissiveColor, 0.2, 0, 0 );
            } else {
              gl.uniform3f(u_material.emissiveColor, 0.2, 0, 0 );
            }
            pushMatrix();
            mat4.rotateZ(modelview,modelview,i*Math.PI/10);
            pushMatrix();
            mat4.translate(modelview, modelview, [0, 0, 0.3]);
            lampRingSlice.render();
            popMatrix();
            lampSlice.render();
            popMatrix();
          }
        };

        lampHalf();
        pushMatrix();
        mat4.rotateZ(modelview,modelview,Math.PI);
        lampHalf();
        popMatrix();
      };

      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,6.7]);
      alarm();
      popMatrix();

      gl.uniform3f(u_material.emissiveColor, 0, 0, 0 );
    }

    function fence() {
      currentColor = [0.5,0.5,0.5,1];
      pushMatrix();
      mat4.translate(modelview,modelview,[-18,0,20]);
      mat4.rotateY(modelview,modelview,Math.PI/2);
      mat4.scale(modelview,modelview,[0.2,0.2,36]);
      cylinder.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[18,0,20]);
      mat4.rotateX(modelview,modelview,Math.PI/2);
      mat4.scale(modelview,modelview,[0.2,0.2,20]);
      cylinder.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[-18,0,20]);
      mat4.rotateX(modelview,modelview,Math.PI/2);
      mat4.scale(modelview,modelview,[0.2,0.2,20]);
      cylinder.render();
      popMatrix();

      var fencePiece = function(length) {
        pushMatrix();
        mat4.scale(modelview,modelview,[0.05,0.05,length]);
        cylinder.render();
        popMatrix();
      };
      var wireRing = function() {
        pushMatrix();
        mat4.translate(modelview,modelview,[0,0,5.6]);
        mat4.rotateZ(modelview,modelview,Math.PI/4);
        mat4.rotateY(modelview,modelview,Math.PI/2);
        fenceRing.render();
        popMatrix();
      };

      var i;
      var offset = -18;
      for(i=0; i<72; i++) {
        pushMatrix();
        mat4.translate(modelview,modelview,[offset += 0.5,0,15]);
        wireRing();
        fencePiece(5);
        popMatrix();
      }
      offset = 0;
      for(i=0; i<10; i++) {
        pushMatrix();
        mat4.translate(modelview,modelview,[-18,0,20 + (offset -= 0.5)]);
        mat4.rotateY(modelview,modelview,Math.PI/2);
        fencePiece(36);
        popMatrix();
      }
      offset = 0;
      for(i=0; i<20; i++){
        var x = (i>=10) ? 18 : -18;
        if(i === 10) offset = 0;
        pushMatrix();
        mat4.translate(modelview,modelview,[x,0,20 + (offset -= 0.5)]);
        mat4.rotateX(modelview,modelview,Math.PI/2);
        fencePiece(20);
        popMatrix();
      }
      offset = 0;
      for(i=0; i<80; i++){
        var x = (i>=40) ? 18 : -18;
        if(i === 40) offset = 0;
        pushMatrix();
        mat4.translate(modelview,modelview,[x,offset -= 0.5,15]);
        wireRing();
        fencePiece(5);
        popMatrix();
      }
    }

    function missile() {
      pushMatrix();
      // translation to simulate the missile launching
      var color = 0;
      if(launching && frameNumber > 60){
        missileZ = (frameNumber-60)*(frameNumber-60)/1000;
        color = (frameNumber-60)*2.5/500;
      }
      mat4.translate(modelview,modelview,[0,0,missileZ]);

      // create the 4 nozzles
      currentColor = [0.08,0.08,0.08,1];
      pushMatrix();
      mat4.translate(modelview,modelview,[0.33,0.33,0]);
      nozzle.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[-0.33,-0.33,0]);
      nozzle.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[0.33,-0.33,0]);
      nozzle.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[-0.33,0.33,0]);
      nozzle.render();
      popMatrix();

      // create missile body
      currentColor = [0.3+color,0.3+color,0.3+color,1];
      gl.uniform1i(u_texture, 1);   // use stage2 texture
      pushMatrix();
      mat4.scale(modelview,modelview,[1.5,1.5,4]);
      mat3.identity(textureTransform);
      mat3.rotate(textureTransform,textureTransform,Math.PI,[0,0,1]);
      stage2.render();
      popMatrix();
      pushMatrix();
      gl.uniform1i(u_texture, 0);   // use usaf texture
      mat4.translate(modelview,modelview,[0,0,5]);
      mat4.rotateZ(modelview,modelview,Math.PI/20);
      mat4.scale(modelview,modelview,[1,1,2.5]);
      mat3.identity(textureTransform);
      mat3.scale(textureTransform,textureTransform,[1.1,1,1]);
      stage1.render();
      popMatrix();
      pushMatrix();
      gl.uniform1i(u_texture, 2);  // use white texture
      mat4.translate(modelview,modelview,[0,0,7.5]);
      mat4.scale(modelview,modelview,[1,1,1.75]);
      interstage.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,4]);
      mat4.scale(modelview,modelview,[1.5,1.5,3]);
      interstage.render();
      popMatrix();

      // renders the thrust cones while the missile is launching
      if(launching) {
        currentColor = [1,1,1,1];
        if(frameNumber%5 === 0) stage++;   // update the stage every 5 frames
        if(stage > 4 && frameNumber < 120) stage = 1;  // use stages 1-4 for the first 120 frames
        else if(stage > 8) stage = 6;  // after that use only stages 4-8

        gl.uniform1i(u_texture, 6);   // use flame texture
        pushMatrix();
        mat4.translate(modelview, modelview, [-0.33, 0.33, -2]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 0.2]);
        thrustCones[stage-1].render();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [-0.33, -0.33, -2]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 0.2]);
        thrustCones[stage-1].render();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.33, -0.33, -2]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 0.2]);
        thrustCones[stage-1].render();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.33, 0.33, -2]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 0.2]);
        thrustCones[stage-1].render();
        popMatrix();
      }
      popMatrix();
    }

    function launchTube() {
      currentColor = [0.8,0.8,0.8,1];
      pushMatrix();
      mat4.rotateZ(modelview,modelview,-Math.PI/4);
      tube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,-12.5]);
      mat4.scale(modelview,modelview,[7,7,0.5]);
      cylinder.render();
      popMatrix();
    }

    function upperGround() {
      var x = 7.5*3, y = 7.5*2;
      currentColor = [0.5,0.5,0.5,1];
      var i,j;

      for(i=0; i < 3; i++) {
        for(j=0; j < 2; j++) {
          if(x > 15 || y > 7.5){
             gl.uniform1i(u_texture, 3); // use grass texture
          } else {
            gl.uniform1i(u_texture, 4); // use concrete texture
          }
          if(i === 1 && j === 1){
            pushMatrix();
            mat4.translate(modelview, modelview, [x -= 7.5, y, 0]);
            mat4.scale(modelview, modelview, [0.85, 0.85, 1]);
            mat3.scale(textureTransform, textureTransform, [0.35,0.35]);
            pasGround();
            mat3.identity(textureTransform);
            popMatrix();
            continue;
          }
          pushMatrix();
          mat4.translate(modelview, modelview, [x -= 7.5, y, 0]);
          mat4.scale(modelview, modelview, [2.5, 2.5, 1]);
          gcube.render();
          popMatrix();
        }
        y-=7.5;
        x = 7.5*3;
      }
      pushMatrix();
      mat4.translate(modelview,modelview,[0,7.5,0]);
      mat4.scale(modelview, modelview, [2.5, 2.5, 1]);
      gcube.render();
      popMatrix();
      gl.uniform1i(u_texture, 3); // use grass texture
      pushMatrix();
      mat4.translate(modelview,modelview,[0,15,0])
      mat4.scale(modelview, modelview, [2.5, 2.5, 1]);
      gcube.render();
      popMatrix();

      x = -7.5*3;
      y = 7.5*2;
      for(i=0; i < 3; i++) {
        for(j=0; j < 2; j++) {
          if(x < -15 || y > 7.5){
            gl.uniform1i(u_texture, 3); // use grass texture
          } else {
            gl.uniform1i(u_texture, 4); // use concrete texture
          }
          pushMatrix();
          mat4.translate(modelview, modelview, [x += 7.5, y, 0]);
          mat4.scale(modelview, modelview, [2.5, 2.5, 1]);
          gcube.render();
          popMatrix();
        }
        y-=7.5;
        x = -7.5*3;
      }

      var offset = -3.75 * 5;
      for(i = 0; i < 8; i++){
        if(offset === -3.75) offset += 7.5;
        if(offset < -3.75*3 || offset > 3.75*2) {
          gl.uniform1i(u_texture, 3);
        } else {
          gl.uniform1i(u_texture, 4);
        }
        pushMatrix();
        mat4.translate(modelview,modelview,[offset += 3.75,-3.75,-1.5]);
        mat4.scale(modelview,modelview,[3.75/3,1.5,1]);
        mat4.rotateX(modelview,modelview,Math.PI/2);
        mat4.rotateY(modelview,modelview,-Math.PI/2);
        gwedge.render();
        popMatrix();

      }
    }

    function launcherClosure() {
      gl.uniform1i(u_texture, 5);  // use concrete texture
      mat3.identity(textureTransform);
      pushMatrix();
      mat4.scale(modelview, modelview, [2.5, 2.5, 0.85]);
      gcube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[3.75,-3.75,-1.275]);
      mat4.scale(modelview,modelview,[2*3.75/3,1.275,0.85]);
      mat4.rotateX(modelview,modelview,Math.PI/2);
      mat4.rotateY(modelview,modelview,-Math.PI/2);
      gwedge.render();
      popMatrix();

      currentColor = [0.2,0.2,0.2,1];
      pushMatrix();
      mat4.translate(modelview,modelview,[3,3,-2.55/2]);
      mat4.rotateY(modelview,modelview,Math.PI/2);
      lcWheel.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[3,-5,-2.55/2]);
      mat4.rotateY(modelview,modelview,Math.PI/2);
      lcWheel.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[-3,3,-2.55/2]);
      mat4.rotateY(modelview,modelview,Math.PI/2);
      lcWheel.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[-3,-5,-2.55/2]);
      mat4.rotateY(modelview,modelview,Math.PI/2);
      lcWheel.render();
      popMatrix();

    }

    function launcherClosureTracks() {
      // individual track
      var launcherClosureTrack = function() {
        currentColor = [0.2196, 0.1333, 0.0196, 1];
        pushMatrix();
        mat4.scale(modelview,modelview,[5,120,1]);
        lcTrack.render();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview,modelview,[0.4,0,0.2]);
        mat4.scale(modelview,modelview,[1,120,1]);
        lcTrack.render();
        popMatrix();
      };
      pushMatrix();
      mat4.translate(modelview,modelview,[-3,0,0]);
      launcherClosureTrack();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[3,0,0]);
      mat4.rotateZ(modelview,modelview,Math.PI);
      launcherClosureTrack();
      popMatrix();
    }

    function pasGround() {
      gl.uniform1i(u_texture, 4);
      pushMatrix();
      mat4.translate(modelview,modelview,[0,3,0]);
      gcube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[3,3,0]);
      gcube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[3,0,0]);
      gcube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[3,-3,0]);
      gcube.render();
      popMatrix();
      pushMatrix();
      gcube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[-3,-3,0]);
      gcube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[-3,0,0]);
      gcube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[0,3,0]);
      gcube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[-3,3,0]);
      gcube.render();
      popMatrix();
    }

    function lowerEquipRoom(){
      currentColor = [0.8,0.8,0.8,1];
      pushMatrix();
      mat4.scale(modelview,modelview,[2,2,0.2]);
      tube.render();
      popMatrix();

      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,-2.5]);
      lerFloor.render();
      popMatrix();

      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,2.5]);
      lerFloor.render();
      popMatrix();

      // simple block that represents an equipment rack in the LER
      var drawRack = function() {
        pushMatrix();
        mat4.rotateZ(modelview,modelview,Math.PI/4);
        mat4.translate(modelview,modelview,[0,-5.9,-0.6]);
        mat4.scale(modelview,modelview,[0.4,0.3,0.75]);
        rack.render();
        popMatrix();
      };

      pushMatrix();
      mat4.rotateZ(modelview,modelview,Math.PI/3);
      drawRack();
      popMatrix();
      pushMatrix();
      mat4.rotateZ(modelview,modelview,1.4*Math.PI/3);
      drawRack();
      popMatrix();
      pushMatrix();
      mat4.rotateZ(modelview,modelview,-1.4*Math.PI/3);
      drawRack();
      popMatrix();
      pushMatrix();
      mat4.rotateZ(modelview,modelview,-Math.PI/3);
      drawRack();
      popMatrix();
      pushMatrix();
      mat4.rotateZ(modelview,modelview,-2.2*Math.PI/3);
      drawRack();
      popMatrix();
    }

    function pas() {
      pushMatrix();
      mat4.scale(modelview,modelview,[1,1,1.75]);
      pasTube.render();
      popMatrix();
      pushMatrix();
      mat4.scale(modelview,modelview,[0.75,0.75,1.75]);
      pasTube.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,7]);
      pasTubeRing.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,-7.045]);
      mat4.scale(modelview,modelview,[3.2,3.2,1]);
      cylinder.render();
      popMatrix();
      pushMatrix();
      mat4.rotateZ(modelview,modelview,-2*Math.PI/8);
      mat4.translate(modelview,modelview,[0,-1.6,-5.17]);
      mat4.scale(modelview,modelview,[0.64,0.64,0.75]);
      rack.render();
      popMatrix();
    }

    function ladder() {
      pushMatrix();
      mat4.translate(modelview,modelview,[-1,0,0]);
      mat4.scale(modelview,modelview,[0.05,0.1,6]);
      rack.render();
      popMatrix();
      pushMatrix();
      mat4.translate(modelview,modelview,[1,0,0]);
      mat4.scale(modelview,modelview,[0.05,0.1,6]);
      rack.render();
      popMatrix();

      var drawRung = function(zOffset) {
        pushMatrix();
        mat4.translate(modelview,modelview,[-1,0,zOffset]);
        mat4.rotateY(modelview,modelview,Math.PI/2);
        mat4.scale(modelview,modelview,[0.2,0.2,2]);
        cylinder.render();
        popMatrix();
      };

      var offset = 16;
      for(var i=0; i<20; i++){
        drawRung(offset -= 1.5);
      }
    }

    function pahAssembly() {
      var rotation = 0.3*Math.sin((-pahOpenValue)*(Math.PI/2)); // rotation while opening access hatch

      pah();
      pushMatrix();
      mat4.translate(modelview,modelview,[0,3.1,-0.38]);
      mat4.rotateX(modelview,modelview,rotation);
      mat4.rotateX(modelview,modelview,9*Math.PI/20);
      pahActuator();
      popMatrix();

      currentColor = [0.5,0.5,0.5,1];
      pushMatrix();
      mat4.translate(modelview,modelview,[0,3.1,-0.4]);
      mat4.scale(modelview,modelview,[0.02,0.06,0.06]);
      rack.render();
      popMatrix();

    }

    function pahActuator() {
      // the two blue cylinders that make up the actuator drum
      var pahActuatorDrum = function() {
        // hand crank attached to the actuator drum
        var handCrank = function() {
          pushMatrix();
          // handle rotates as access hatch opens
          mat4.rotateZ(modelview,modelview,-pahOpenValue*100*Math.PI/10);

          currentColor = [0,0,0.15,1];
          pushMatrix();
          mat4.scale(modelview,modelview,[0.15,0.15,0.8]);
          cylinder.render();
          popMatrix();

          currentColor = [0.9,0.9,0.9,1];
          pushMatrix();
          mat4.translate(modelview,modelview,[0,0.3,0.8]);
          mat4.rotateX(modelview,modelview,Math.PI/2);
          mat4.scale(modelview,modelview,[0.04,0.01,0.15]);
          rack.render();
          popMatrix();

          currentColor = [0.35,0.27,0.15,1];
          pushMatrix();
          mat4.translate(modelview,modelview,[0,0.6,0.8]);
          mat4.scale(modelview,modelview,[0.1,0.1,0.4]);
          cylinder.render();
          popMatrix();
          popMatrix();
        };

        pushMatrix();
        // actuator drum moves down the silver cylinder as access hatch opens
        mat4.translate(modelview,modelview,[0,0,Math.cos((-pahOpenValue)*7*Math.PI/12)+1]);
        pushMatrix();
        currentColor = [0,0,0.15,1];
        mat4.translate(modelview,modelview,[0,0,0.7]);
        mat4.scale(modelview,modelview,[0.15,0.15,1]);
        cylinder.render();
        popMatrix();

        pushMatrix();
        mat4.scale(modelview,modelview,[0.3,0.3,1.4]);
        cylinder.render();
        popMatrix();

        pushMatrix();
        mat4.translate(modelview,modelview,[-0.13,0,0.6]);
        mat4.rotateY(modelview,modelview,Math.PI/2);
        mat4.scale(modelview,modelview,[0.7,0.7,0.7]);
        handCrank();
        popMatrix();
        popMatrix();
      };

      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,0.4]);
      pahActuatorDrum();
      popMatrix();

      currentColor = [0.75,0.75,0.75,1];
      pushMatrix();
      mat4.scale(modelview,modelview,[0.18,0.18,2.5]);
      cylinder.render();
      popMatrix();

    }

    function pah() {
      currentColor = [1,1,0.95,1];
      pushMatrix();
      // access hatch rotates open
      mat4.rotateX(modelview,modelview,-pahOpenValue*7*Math.PI/12);
      mat4.translate(modelview,modelview,[0,-2.15,-0.4]);
      var hollowTube = function() {
        pushMatrix();
        mat4.scale(modelview,modelview,[2/1.6,2/1.6,0.3/8]);
        pasTube.render();
        popMatrix();
        pushMatrix();
        mat4.scale(modelview,modelview,[1,1,0.3/8]);
        pasTube.render();
        popMatrix();

        pushMatrix();
        mat4.translate(modelview,modelview,[0,0,0.15]);
        pahRing.render();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview,modelview,[0,0,-0.15]);
        pahRing.render();
        popMatrix();
      };

      hollowTube();

      currentColor = [0.8,0.8,0.8,1];
      pushMatrix();
      mat4.translate(modelview,modelview,[0,0,0.15]);
      mat4.scale(modelview,modelview,[3.4,3.4,0.15]);
      cylinder.render();
      popMatrix();

      currentColor = [0.5,0.5,0.5,1];
      pushMatrix();
      mat4.translate(modelview,modelview,[0,1.2,0.5]);
      mat4.scale(modelview,modelview,[0.02,0.06,0.12]);
      rack.render();
      popMatrix();
      popMatrix();
    }

    /**
     *  Push a copy of the current modelview matrix onto the matrix stack.
     */
    function pushMatrix() {
      matrixStack.push( mat4.clone(modelview) );
    }

    /**
     *  Restore the modelview matrix to a value popped from the matrix stack.
     */
    function popMatrix() {
      modelview = matrixStack.pop();
    }

    /**
     *  Create one of the basic objects.  The modelData holds the data for
     *  an IFS using the structure from basic-objects-IFS.js.  This function
     *  creates VBOs to hold the coordinates, normal vectors, and indices
     *  from the IFS, and it loads the data into those buffers.  The function
     *  creates a new object whose properties are the identifies of the
     *  VBOs.  The new object also has a function, render(), that can be called to
     *  render the object, using all the data from the buffers.  That object
     *  is returned as the value of the function.  (The second parameter,
     *  xtraTranslate, is there because this program was ported from a Java
     *  version where cylinders were created in a different position, with
     *  the base on the xy-plane instead of with their center at the origin.
     *  The xtraTranslate parameter is a 3-vector that is applied as a
     *  translation to the rendered object.  It is used to move the cylinders
     *  into the position expected by the code that was ported from Java.)
     */
    function createModel(modelData, useTexture, xtraTranslate) {
      var model = {};
      model.coordsBuffer = gl.createBuffer();
      model.normalBuffer = gl.createBuffer();
      model.indexBuffer = gl.createBuffer();
      model.texCoordsBuffer = gl.createBuffer();
      model.count = modelData.indices.length;
      if (xtraTranslate)
        model.xtraTranslate = xtraTranslate;
      else
        model.xtraTranslate = null;
      gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, model.texCoordsBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexTextureCoords, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
      model.render = function() {  // This function will render the object.
        // Since the buffer from which we are taking the coordinates and normals
        // change each time an object is drawn, we have to use gl.vertexAttribPointer
        // to specify the location of the data. And to do that, we must first
        // bind the buffer that contains the data.  Similarly, we have to
        // bind this object's index buffer before calling gl.drawElements.
        gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
        gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordsBuffer);
        gl.vertexAttribPointer(a_texCoords_loc, 2, gl.FLOAT, false, 0, 0);
        gl.uniform1f(u_useTexture, useTexture);
        gl.uniform4fv(u_material.diffuseColor, currentColor);
        if(useTexture > 0.5){
          gl.uniformMatrix3fv(u_textureTransform,false,textureTransform);
        }
        if (this.xtraTranslate) {
          pushMatrix();
          mat4.translate(modelview,modelview,this.xtraTranslate);
        }
        gl.uniformMatrix4fv(u_modelview, false, modelview );
        mat3.normalFromMat4(normalMatrix, modelview);
        gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
        if (this.xtraTranslate) {
          popMatrix();
        }
      };
      return model;
    }

    /**
     *  Loads a texture image asynchronously.  The first parameter is the url
     *  from which the image is to be loaded.  The second parameter is the
     *  texture object into which the image is to be loaded.  When the image
     *  has finished loading, the draw() function will be called to draw the
     *  triangle with the texture.  (Also, if an error occurs during loading,
     *  an error message is displayed on the page, and draw() is called to
     *  draw the triangle without the texture.)
     */
    function loadTexture( url, textureObject, textureEnum) {
      var img = new Image();  //  A DOM image element to represent the image.
      img.onload = function() {

        gl.activeTexture(textureEnum);

        gl.bindTexture(gl.TEXTURE_2D, textureObject);
        try {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        } catch (e) {
          document.getElementById("notextures").innerHTML =
              "Error loading textures. May need to temporarily disable Same Origin Policy in browser.";
        }
        gl.generateMipmap(gl.TEXTURE_2D);  // Create mipmaps

        draw();  // Draw the canvas, with the texture.
      };
      img.src = url;  // Start loading of the image.
    }

    /* Creates a program for use in the WebGL context gl, and returns the
     * identifier for that program.  If an error occurs while compiling or
     * linking the program, an exception of type String is thrown.  The error
     * string contains the compilation or linking error.  If no error occurs,
     * the program identifier is the return value of the function.
     *    The second and third parameters are the id attributes for <script>
     * elements that contain the source code for the vertex and fragment
     * shaders.
     */
    function createProgram(gl, vertexShaderID, fragmentShaderID) {
      function getTextContent( elementID ) {
        // This nested function retrieves the text content of an
        // element on the web page.  It is used here to get the shader
        // source code from the script elements that contain it.
        var element = document.getElementById(elementID);
        var node = element.firstChild;
        var str = "";
        while (node) {
          if (node.nodeType == 3) // this is a text node
            str += node.textContent;
          node = node.nextSibling;
        }
        return str;
      }
      try {
        var vertexShaderSource = getTextContent( vertexShaderID );
        var fragmentShaderSource = getTextContent( fragmentShaderID );
      }
      catch (e) {
        throw "Error: Could not get shader source code from script elements.";
      }
      var vsh = gl.createShader( gl.VERTEX_SHADER );
      gl.shaderSource(vsh,vertexShaderSource);
      gl.compileShader(vsh);
      if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
        throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
      }
      var fsh = gl.createShader( gl.FRAGMENT_SHADER );
      gl.shaderSource(fsh, fragmentShaderSource);
      gl.compileShader(fsh);
      if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
        throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
      }
      var prog = gl.createProgram();
      gl.attachShader(prog,vsh);
      gl.attachShader(prog, fsh);
      gl.linkProgram(prog);
      if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
        throw "Link error in program:  " + gl.getProgramInfoLog(prog);
      }
      return prog;
    }

    /* Initialize the WebGL context.  Called from init() */
    function initGL() {
      var prog = createProgram(gl,"vshader-source","fshader-source");
      gl.useProgram(prog);
      gl.enable(gl.DEPTH_TEST);

      /* Get attribute and uniform locations */

      a_coords_loc =  gl.getAttribLocation(prog, "a_coords");
      a_normal_loc =  gl.getAttribLocation(prog, "a_normal");
      a_texCoords_loc = gl.getAttribLocation(prog, "a_texCoords");
      gl.enableVertexAttribArray(a_coords_loc);
      gl.enableVertexAttribArray(a_normal_loc);
      gl.enableVertexAttribArray(a_texCoords_loc);

      u_modelview = gl.getUniformLocation(prog, "modelview");
      u_projection = gl.getUniformLocation(prog, "projection");
      u_normalMatrix =  gl.getUniformLocation(prog, "normalMatrix");
      u_texture = gl.getUniformLocation(prog, "texture");
      u_textureTransform = gl.getUniformLocation(prog, "textureTransform");
      u_useTexture = gl.getUniformLocation(prog, "useTexture");

      u_material = {
        diffuseColor: gl.getUniformLocation(prog, "material.diffuseColor"),
        specularColor: gl.getUniformLocation(prog, "material.specularColor"),
        emissiveColor: gl.getUniformLocation(prog, "material.emissiveColor"),
        specularExponent: gl.getUniformLocation(prog, "material.specularExponent")
      };
      u_lights = new Array(8);
      var i;
      for (i = 0; i < 8; i++) {
        u_lights[i] = {
          enabled: gl.getUniformLocation(prog, "lights[" + i + "].enabled"),
          position: gl.getUniformLocation(prog, "lights[" + i + "].position"),
          color: gl.getUniformLocation(prog, "lights[" + i + "].color"),
          spotDirection: gl.getUniformLocation(prog, "lights[" + i + "].spotDirection"),
          spotCosineCutoff: gl.getUniformLocation(prog, "lights[" + i + "].spotCosineCutoff"),
          spotExponent: gl.getUniformLocation(prog, "lights[" + i + "].spotExponent"),
          attenuation: gl.getUniformLocation(prog, "lights[" + i + "].attenuation")
        };
      }

      // set basic material properties
      gl.uniform3f( u_material.specularColor, 0.1, 0.1, 0.1 );
      gl.uniform1f( u_material.specularExponent, 16 );
      gl.uniform3f( u_material.emissiveColor, 0, 0, 0);


      for (i = 0; i < 8; i++) { // set defaults for lights
        gl.uniform1i( u_lights[i].enabled, 0 );
        gl.uniform4f( u_lights[i].position, 0, 0, 1, 0 );
        gl.uniform1f( u_lights[i].spotCosineCutoff, 0); // not a spotlight
        gl.uniform3f( u_lights[i].spotDirection, 0,0,-1);
        gl.uniform1f( u_lights[i].spotExponent, 5);
        gl.uniform1f( u_lights[i].attenuation, 0); // no attenuation
        gl.uniform3f( u_lights[i].color, 1,1,1 );
      }

      gl.uniform4f( u_lights[0].position, 0,0,0,1 ); // positional, at viewpoint
      gl.uniform3f( u_lights[0].color, 0.7,0.7,0.7 );  // dim

      // lights 2, 3, and 4 are launch tube lights
      // light 5 is the PAS light
      gl.uniform1f( u_lights[2].spotCosineCutoff, Math.cos(Math.PI/2) );
      gl.uniform1f(u_lights[2].attenuation, 0.04);
      gl.uniform1f( u_lights[3].spotCosineCutoff, Math.cos(Math.PI/2) );
      gl.uniform1f(u_lights[3].attenuation, 0.04);
      gl.uniform1f( u_lights[4].spotCosineCutoff, Math.cos(Math.PI/2) );
      gl.uniform1f(u_lights[4].attenuation, 0.04);
      gl.uniform1f( u_lights[5].spotCosineCutoff, Math.cos(Math.PI) );
      gl.uniform1f(u_lights[5].attenuation, 0.04);
      gl.uniform3f( u_lights[2].color, 0.5, 0.5, 0.4 );
      gl.uniform3f( u_lights[3].color, 0.5, 0.5, 0.4 );
      gl.uniform3f( u_lights[4].color, 0.5, 0.5, 0.4 );
      gl.uniform3f( u_lights[5].color, 0.5, 0.5, 0.4 );
      gl.uniform1f( u_lights[5].spotExponent, 8);
      gl.uniform1f( u_lights[4].spotExponent, 0.5);


      gl.uniform1f( u_lights[6].spotCosineCutoff, Math.cos(Math.PI/4) );
      gl.uniform1f(u_lights[6].attenuation, 0.2);
      gl.uniform3f( u_lights[6].color, 0.8, 0, 0 );
      gl.uniform1f( u_lights[6].spotExponent, 6.5);
      gl.uniform1f( u_lights[7].spotExponent, 6.5);

      gl.uniform1f( u_lights[7].spotCosineCutoff, Math.cos(Math.PI/4) );
      gl.uniform1f(u_lights[7].attenuation, 0.2);
      gl.uniform3f( u_lights[7].color, 0.8, 0, 0 );

      textureEnums = [
        gl.TEXTURE0,  // usaf texture
        gl.TEXTURE1,  // missile stage 2 texture
        gl.TEXTURE2,  // white texture
        gl.TEXTURE3,  // grass texture
        gl.TEXTURE4,  // concrete texture
        gl.TEXTURE5,  // modified concrete for the launcher closure
        gl.TEXTURE6   // flames texture
      ];

      // load all of the textures
      for(i=0; i<textureURLs.length; i++) {
        loadTexture(textureURLs[i], textureObjects[i] = gl.createTexture(), textureEnums[i]);
      }

    } // end initGL()



    //--------------------------------- animation framework ------------------------------

    function frame() {
      if (frameNumber < 500) {
        frameNumber += 1;
        draw();
        requestAnimationFrame(frame);
      } else {
        frameNumber += 1;
        launching = false;
        draw();
        requestAnimationFrame(frame);
      }
    }

    // attempts to launch, only works if launcher closure is fully open
    function doLaunch() {
      if(!lcOpen) {
        document.getElementById("launchError").innerHTML = "Launcher Closure must be fully open to launch!";
        return;
      } else {
        document.getElementById("launchError").innerHTML = "";
      }

      if(!launching && missileReady) {
        launching = true;
        missileReady = false;
        frameNumber = 0;
      }
    }

    // Opens and closes launcher closure using the html range slider
    // Does not function if the missile is launching
    function moveLC() {
      if(!launching) {
        var value = document.getElementById("lcvalue").value;
        lcOpen = (value > 95);
        lcOpenValue = value / 100 * 12;
      }
    }

    // Opens and closes the personnel access hatch
    function movePAH() {
      pahOpenValue = document.getElementById("pahvalue").value/100;
    }

    //-------------------------------------------------------------------------


    /**
     * initialization function that will be called when the page has loaded
     */
    function init() {
      try {
        var canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl") ||
            canvas.getContext("experimental-webgl");
        if ( ! gl ) {
          throw "Browser does not support WebGL";
        }
      }
      catch (e) {
        document.getElementById("message").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
        return;
      }
      try {
        initGL();  // initialize the WebGL graphics context
      }
      catch (e) {
        document.getElementById("message").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
        return;
      }

      // reset button resets the scene and returns the missile to the launch tube
      document.getElementById("reset").onclick = function() {
        rotator.setView(80,[0,-4,2]);
        frameNumber = 0;
        launching = false;
        pahOpenValue = 0;
        document.getElementById("pahvalue").value = 0;
        lcOpenValue = 0;
        lcOpen = false;
        document.getElementById("lcvalue").value = 0;
        document.getElementById("launchError").innerHTML = "";
        missileZ = 0;
        missileReady = true;
        draw();
      };

      // create the basic models used in the scene
      rack = createModel(cube(5),0.0);
      cone = createModel(uvCone(0.5,1,64,false),0.0,[0,0,.5]);
      cylinder = createModel(uvCylinder(),0.0,[0,0,.5]);
      gcube = createModel(cube(3),1.0);
      gwedge = createModel(wedge(3), 1.0);
      nozzle = createModel(uvCone(0.3,0.8,12,true));
      stage1 = createModel(uvCylinder(),1.0,[0,0,.5]);
      stage2 = createModel(uvCylinder(),1.0,[0,0,0.5]);
      interstage = createModel(uvCone(0.5,1,64,false),1.0,[0,0,0.5]);
      launchTubeLamp = createModel(uvSphere(0.5,12,12,Math.PI));
      tube = createModel(uvCylinder(3.5,25,64,true,true,3*Math.PI/2));
      lcWheel = createModel(uvCylinder(0.45,0.45),0.0);
      lcTrack = createModel(cube(0.2),0.0);
      lerFloor = createModel(ring2(3.5,7,64,3*Math.PI/2));
      pasTube = createModel(uvCylinder(1.6,8,64,true,true),0.0);
      pasTubeRing = createModel(ring2(1.2,1.6,64),0.0);
      fenceRing = createModel(ring(0.95,1,32),0.0);
      pahRing = createModel(ring(1.6,2,64),0.0);
      thrustCones = [8];
      for(var i=0; i<8; i++){
        var stage = i+1;
        thrustCones[i] = createModel(uvCone(stage*0.5, stage*4,64,false),1.0);
      }
      lampRingSlice = createModel(ring2(0,0.25,16,Math.PI/10));
      lampSlice = createModel(uvCylinder(0.25,0.6,16,true,true,Math.PI/10));

      rotator = new TrackballRotator(canvas,function() {
          draw();
      },60,[0,-4,2]);

      document.addEventListener("keydown", doKey, false);
      document.addEventListener("mousemove", function(evt) {
        mouseX = evt.clientX;
        mouseY = evt.clientY;
      }, false);

      requestAnimationFrame(frame);
    }

    // moves the entire scene along the axes
    function doKey(evt) {
      var key = evt.keyCode;
      var translating = true;
      switch(key) {
        case 37: translateWorld([-1,0,0]);  break;    // left arrow
        case 39: translateWorld([1,0,0]); break;    // right arrow
        case 38: translateWorld([0,0,1]);  break;    // up arrow
        case 40: translateWorld([0,0,-1]);  break;    // down arrow
        case 33: translateWorld([0,1,0]);  break;    // page up
        case 34: translateWorld([0,-1,0]);  break;    // page down
        case 36: keyTranslation = [0,0,-5]; draw(); break;  // home
        default: translating = false;
      }
      if(translating) evt.preventDefault();
    }

    // updates the translation of the entire scene.
    // limits translations to 20 in any direction
    function translateWorld(vTranslation) {
      var temp = [3];
      for(var i=0; i<3; i++){
        temp[i] = keyTranslation[i] + vTranslation[i];
        if(Math.abs(temp[i]) > 20){
          return;
        }
      }
      keyTranslation = temp;
      draw();
    }

  </script>
</head>
<body onload="init()">

<h2>Minuteman III Launch Facility</h2>
<h3>By: Logan Hershberger</h3>

<noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>
<p id="notextures" style="color: red"></p>
<p id="message">Drag your mouse on the model to rotate it.<br>
  Scroll up and down to zoom in and out.<br>
  Use the arrow keys, page up, and page down to move the scene.<br>
  Press the home button to reset the view of the scene.<br>
</p>

<p>
  <strong>Lights:  </strong>
  <label><input type="checkbox" id="ltlights" onchange="draw()">Launch Tube Lights</label>
  <label><input type="checkbox" id="sunlight" onchange="draw()" checked="true">Sunlight</label>
  <label><input type="checkbox" id="paslight" onchange="draw()">Access Shaft Light</label>
</p>
<p>
  <label><input type="range" id="lcvalue" min="0" max="100" value="0" onInput="moveLC()"> Open Launcher Closure</label><br>
  <label><input type="range" id="pahvalue" min="0" max="100" value="0" onInput="movePAH()"> Open Access Hatch</label><br>
  <button id="launch" onclick="doLaunch()" style="background-color: red">LAUNCH</button>
  <button id="reset" style="margin-left:40px">Reset</button>
</p>
<p id="launchError" style="color: red"></p>


<div>

  <canvas width=700 height=700 id="webglcanvas" style="background-color:blue"></canvas>

</div>
</body>
</html>
